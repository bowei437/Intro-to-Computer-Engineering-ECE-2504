//   *************************************
//   Do not modify this file. 
//   *************************************


//  ECE 2504  
//  Top level file for design project 4
//  The Simple CPU from chapter 9
//  
//  Tom Martin 11/29/2012
//  This is a simplified version of the basiccpu module
//  created by Xin Xin in June 2012.

//  Changes:
//  1. The accelerometer has been removed
//  2. The modules have been re-arranged in the files 
//     to indicate which modules can be changed and which
//     must not be changed. 
//  3. This version uses all four DIP switches to control the LEDs 
//     instead of having one control whether the clock is enabled
//     by the pushbutton.
//  4. KEY0 is the reset and KEY1 is the clock enable to be consistent
//     with project 2.
//  5. The synthesis keep directive has been added to signals 
//     of interest in the cpu module.
//  6. Add toggling of LEDS using KEY[0] for SW[3:1] = 110 and 111
//     so that r6 and r7 can be displayed.   Might lead to poor behavior, 
//     but the board is input-constrained.
//
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`timescale 1 ns/1 ps

module DP4_ECE2504(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;


//=======================================================
//  REG/WIRE declarations
//=======================================================


wire cpu0_clk;
wire cpu0_clk_en;
wire cpu0_rst;
wire [15:0] r0,r1,r2,r3,r4,r5,r6, r7, PC, IR, mux6, mux7;
wire rst_inv;
wire CLOCK_50;

//=======================================================
//  Structural coding
//=======================================================


reg  cpu0_clk_en_delay0, cpu0_clk_en_delay1;
reg [7:0] counter;

assign rst_inv = ~KEY[0]; // In this sense, rst should be a active low signal.


wire cpu_clk;

assign cpu_clk =  cpu0_clk; 

cpu cpu0
( 
   .rst(rst_inv), 
	.clk(cpu_clk), 
	.r0(r0),
	.r1(r1),
	.r2(r2),
	.r3(r3),
	.r4(r4),
	.r5(r5),
	.r6(r6),
	.r7(r7),
	.IR(IR),
	.PC(PC)
);



// The following finite state machine and clock assignments allows the CPU to 
// use KEY1 as the clock signal.  KEY1 is gated with the 50 MHz clock to 
// generate one 50 MHz clock pulse every time KEY1 is pushed.      
// 
// This finite state machine generates one clock enable signal per button push.
button_fsm button_fsm0
( 
  .rst(rst_inv), 
  .clk(CLOCK_50), 
  .button(KEY[1]), 
  .cpu0_clk_en(cpu0_clk_en)
 );

 //This is Altera's recommended way to implement clock gating. 	
 always@(posedge CLOCK_50) //make sure cpu0_clk_en_delay0 is one clock cycle
   cpu0_clk_en_delay0 = cpu0_clk_en;
 always@(negedge CLOCK_50)
   cpu0_clk_en_delay1 = cpu0_clk_en_delay0;
 assign cpu0_clk =  cpu0_clk_en_delay1 & CLOCK_50;
//   End of clock generation portion.

// Use KEY[0] to select between PC/r6 and IR/r7 for  LED display
// When resetting the device (with key0 pressed), the PC will not be displayed, r6 will be. 
// 
assign mux6 = (KEY[0] == 1'b1 )? PC:r6;
assign mux7 = (KEY[0] == 1'b1 )? IR:r7;

 
// Assign the LEDs based upon the DIP switch settings.  
mux16_1_8bits LED_mux(LED, SW, mux7[15:8], mux7[7:0], mux6[15:8], mux6[7:0], r5[15:8], r5[7:0], r4[15:8], r4[7:0], r3[15:8], r3[7:0], r2[15:8], r2[7:0], r1[15:8], r1[7:0], r0[15:8], r0[7:0]);

endmodule


// The rest of this file contains the modules that must not be modified.

// **************************************************************
// You are not permitted to modify this file.
// ****************************************************************
//  Created by Tom Martin
//  15 October 2012
//
//
// mux16_1_8bits is a 16-to-1 mux that is 8 bits wide
// 

module mux16_1_8bits(mux_out, select, i15, i14, i13, i12, i11, i10, i9, i8, i7, i6, i5, i4, i3, i2, i1, i0);
	output [7:0] mux_out;
	input [3:0] select;
	input [7:0] i15, i14, i13, i12, i11, i10, i9, i8, i7, i6, i5, i4, i3, i2, i1, i0;
	
	
	reg [7:0] mux_out;
	// The syntax of the always statement is that i
	always @(select, i15, i14, i13, i12, i11, i10, i9, i8, i7, i6, i5, i4, i3, i2, i1, i0)
	begin	
		// x and z values are NOT treated as don't-care's
		case(select)
			4'd0: mux_out = i0;
			4'd1: mux_out = i1;
			4'd2: mux_out = i2;
			4'd3: mux_out = i3;
			4'd4: mux_out = i4;
			4'd5: mux_out = i5;
			4'd6: mux_out = i6;
			4'd7: mux_out = i7;
			4'd8: mux_out = i8;
			4'd9: mux_out = i9;
			4'd10: mux_out = i10;
			4'd11: mux_out = i11;
			4'd12: mux_out = i12;
			4'd13: mux_out = i13;
			4'd14: mux_out = i14;
			4'd15: mux_out = i15;
			// The default should never happen.
			default: mux_out = 8'bx;  
		endcase
    end


endmodule


/////////////////////////////////////////////////////////////////////////////////////
// 
// Quartus II Verilog Template
// Single port RAM with single read/write address 
//
//	Created: 06/2012, Xin Xin, Virginia Tech


module single_port_ram 
#(parameter DATA_WIDTH=8, parameter ADDR_WIDTH=6)
(
	input [(DATA_WIDTH-1):0] data,
	input [(ADDR_WIDTH-1):0] addr,
	input we, clk,
	output [(DATA_WIDTH-1):0] q
);

	// Declare the RAM variable
	reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];

	// Variable to hold the registered read address
	reg [ADDR_WIDTH-1:0] addr_reg;
	integer i;
	
	initial
     begin
       $readmemh("data.txt", ram);
     end	

	
	//initial for (i=0; i<((1<<(ADDR_WIDTH))-1); i=i+1) ram[i] = 0;
	always @ (posedge clk)
	begin
		// Write
		if (we)
			ram[addr] <= data;

		addr_reg <= addr;
	end

	// Continuous assignment implies read returns NEW data.
	// This is the natural behavior of the TriMatrix memory
	// blocks in Single Port mode.  
	// 
	//  TLM, 11/29/2012: Was ram[addr_reg] but that makes the output data lag by one clock cycle.
	assign q = ram[addr];

endmodule


//PC controller
//v overflow
//c carry out
//n negative
//z zero

// Created by Xin Xin, June 2012.
// The PC register determines its next value based upon the
// which instruction is being executed and the N, Z,, flags.


`timescale 1 ns/1 ps
module pc_controller ( rst, clk, N,C,V,Z,PL, JB, BC, PC, ld_pc, jp_addr);

	input clk;
	input rst;
	input N,C,V,Z,PL,JB,BC;
	output reg [15 : 0] PC;
	input [15:0] ld_pc,jp_addr;
	
wire [3:0] status;
wire [3:0] ctrl_pc;

reg [15:0] next_pc;

assign ctrl_pc = {rst,PL,JB,BC};  //concatenate PC control bits


always@(posedge clk)
  if(rst == 1'b1)  PC <=16'h0000;
  else PC <= next_pc;

always@(N or Z or ctrl_pc or PC or jp_addr or ld_pc)
      casex (ctrl_pc)
		  4'b1xxx: next_pc = 16'h0000; 
        4'b0110: next_pc = jp_addr;
		  4'b0111: next_pc = jp_addr;
		  4'b0101: if(N==1'b1) next_pc = PC + ld_pc ; else next_pc = PC + 1'b1;  
		  4'b0100: if(Z==1'b1) next_pc = PC + ld_pc ; else next_pc = PC + 1'b1; 
		  default: next_pc = PC + 1'b1; 
		endcase
endmodule


// two to one mux
module mux
(
	input [15:0] din_1,
	input [15:0] din_0,
	input sel,
	output [15:0] q
);

assign q = (sel == 1)? din_1:din_0;

endmodule


/////////////////////////////////////////////////////////////////////////////////////
// 
// Quartus II Verilog Template
// instr rom with single read/write address 
//
//	Created: 06/2012, Xin Xin, Virginia Tech
module instruction_rom 
#(parameter DATA_WIDTH=8, parameter ADDR_WIDTH=6)
(
	//input [(DATA_WIDTH-1):0] data,
	input [(ADDR_WIDTH-1):0] addr,
	//input we,
	input clk,
	input rst,
	output  [(DATA_WIDTH-1):0] q
);

	// Declare the RoM variable
	reg [DATA_WIDTH-1:0] rom[2**ADDR_WIDTH-1:0];
	
	initial
     begin
       $readmemh("instruction.txt", rom);
     end	
	
/*	
	always @ (posedge clk)
	begin
	  if (rst == 1'b1) q<= 16'h0000;
      else q <= rom[addr];
	end
*/

assign q = (rst == 1'b1)?16'h0000 :rom[addr];  //make this component purely combinational in order to meet "one clock cycle CPU" requirement 

endmodule



// Created by Xin Xin, June 2012.
// Implements the function unit for the Simple Computer from Chapter 9
// ECE 2504
//V OVERFLOW
//C Carry out
//N Negtive
//Z Zero
// Do not modify this module.
module function_unit
(
	input [3:0] FS,
	input [15:0] A,B,
	output V,C,N,Z,
	output [15:0] F
);

reg [16:0] temp_F;
wire [16:0] temp_A, temp_B; //zero ext

assign temp_A = {1'b0, A};
assign temp_B = {1'b0, B};

always@(FS or temp_A or temp_B)
      case (FS)
		  4'b0000: temp_F = temp_A;
		  4'b0001: temp_F = temp_A + 1'b1;
		  4'b0010: temp_F = temp_A + temp_B;
		  4'b0011: temp_F = temp_A + temp_B + 1'b1; 
		  4'b0100: temp_F = temp_A + (~ temp_B); 
		  4'b0101: temp_F = temp_A + (~ temp_B) + 1'b1;
		  4'b0110: temp_F = temp_A - 1'b1; 
		  4'b0111: temp_F = temp_A ;
		  4'b1000: temp_F = temp_A & temp_B; 
		  4'b1001: temp_F = temp_A | temp_B; 
		  4'b1010: temp_F = temp_A ^ temp_B; 
		  4'b1011: temp_F = ~ temp_A ;
		  4'b1100: temp_F = temp_B ; 
		  4'b1101: temp_F = {1'b0,temp_B[16:1]} ; 
		  4'b1110: temp_F = {temp_B[15:0],1'b0} ;
		  default: temp_F = 16'hbaad;  
		endcase
		
assign F = temp_F[15:0]; //truncate

//N,C,V,Z part to be continued...

reg C_0, C_1;

always@(FS or temp_F)
  if(   FS==4'b0001 ||   
        FS==4'b0010 ||
		  FS==4'b0011 ||
	     FS==4'b0100 || 
		  FS==4'b0101 
	  )
	    C_0 <= temp_F[16];
	else
       C_0 <= 1'b0;
		 
always@(FS or temp_F or A)
  if(   FS==4'b0110 && (A!=16'h0000)  )
	    C_1 <= 1'b1;
	else
       C_1 <= 1'b0;

assign C = C_0 & C_1;

assign N = F[15];

//  TLM: 11/11/2012:  V doesn't look right...check this later.  
//  Not important now because the Simple Computer does not use it.
assign V = temp_F[16];

assign Z = (F == 16'h0000)?1'b1:1'b0;

endmodule


// Module created by Xin Xin, June 2012
// for Simple Computer, chapter 9.
// ECE 2504.
// 
// The double_port_ram module implements the register file.
// Do not modify this module.
//
// TLM, 11/29/2012: Added r6, r7 as outputs to help with simulating programs.
module double_port_ram 
(
	input [15:0] data,
	input [2:0] DA,
	input [2:0] AA,
	input [2:0] BA,
	input we, clk,
	input rst,
	output [15:0] a,b,r0,r1,r2,r3,r4,r5, r6, r7
);

	// Declare the RAM variable
	reg [15:0] ram[7:0];

	// Variable to hold the registered read address
	reg [2:0] addr_reg;
	integer i;
	
	//initial for (i=0; i<((1<<(ADDR_WIDTH))-1); i=i+1) ram[i] = 0;
	always @ (posedge clk)
	begin
	   if(rst == 1'b1) begin ram[0]=0;ram[1]=0;ram[2]=0;ram[3]=0;ram[4]=0;ram[5]=0;ram[6]=0;ram[7]=0; end 
		// Write
		else if (we)
			ram[DA] <= data;
		//addr_reg <= DA;
	end

	// Continuous assignment implies read returns NEW data.
	// This is the natural behavior of the TriMatrix memory
	// blocks in Single Port mode.  
	assign a = ram[AA];
	assign b = ram[BA];
	
  assign r0 = ram[0]; 
  assign r1 = ram[1]; 
  assign r2 = ram[2]; 
  assign r3 = ram[3]; 
  assign r4 = ram[4]; 
  assign r5 = ram[5]; 
  assign r6 = ram[6]; 
  assign r7 = ram[7]; 

endmodule

// Created by Xin Xin, June 2012
//
//  This finite state machine is used to generate one clock pulse
//  every time the button is pushed.
//
//  Do not modify this module.

`timescale 1 ns/1 ps
module button_fsm ( rst, clk, button, cpu0_clk_en);

  input rst, clk, button;
  output reg  cpu0_clk_en;



  reg state;  
  reg  next_state;  
  parameter s0 = 1'b0; parameter s1 = 1'b1;  
  
  always @( posedge clk)  
  begin  
    if (rst==1'b1)  state = s0;  
    else   state = next_state;  
  end 
	  
   always @(state or button )  
   begin  
        cpu0_clk_en=1'b0;	
        case (state)  
          s0: begin
					if(button == 1'b0) begin cpu0_clk_en = 1'b1; next_state = s1; end
					else next_state = s0;
				  end
          s1: begin  
			     if(button==1'b1)  next_state = s0 ;
				  else next_state = s1; 
				  end 
          default: next_state = s0;  
        endcase  		  
  end 


endmodule  


/////////////////////////////////////////////////////////////////////////////////////
//
// cpu: This module specifies the top-level component for a single cycle computer
//      as shown in Figure 9-15 in Logic and Computer Design foundamentals for ECE 2504
//      It is mainly a structural module, with the functionality implemented in other modules
//      in this project.
//    
//    
//	Created: 06/2012, Xin Xin, Virginia Tech
//
/////////////////////////////////////////////////////////////////////////////////////

// Modified on 11/11/2012 by Tom Martin
// Removed accelerometers and EEPROM.
// Added IR and PC outputs to make them visible.
// Fixed warnings about the memory address input width.

//  Modified on 11/29/2012 by Tom Martin
//  Added synthesis keep directive to signals of interest.
//  Added r6 and r7 as outputs so that they can be displayed in simulation and 
//  on LEDs.  See notes in top level module.

// You must not change the module declaration.
`timescale 1 ns/1 ps
module cpu ( rst, clk,r0,r1,r2,r3,r4,r5,r6, r7, IR, PC);

	input clk ;
	input rst;
// The following outputs are included so that we can connect them to the LEDS
// to see what is going on inside the CPU.
	output [15 : 0] r0,r1,r2,r3,r4,r5, r6, r7 /* synthesis keep */ ;
	output [15:0] IR, PC /* synthesis keep */ ;
	
//	wire [15:0] r6, r7  /* synthesis noprune */ ;  // the keep directive does not work
	                                              // for nodes with no fan-out...
	
	wire [15:0] instr /* synthesis keep */;
	wire [2:0] DA, AA, BA /* synthesis keep */;
	wire MB /* synthesis keep */;
	wire [3:0] FS /* synthesis keep */ ;
	wire MD,RW,MW,PL,JB,BC,N,C,V,Z /* synthesis keep */ ;
	wire [15:0] constant; 
	wire [15:0] register_file_in, A, B /* synthesis keep */ ;
	
	wire[15:0] mux_b_out /* synthesis keep */;
	wire[15:0] function_unit_out /* synthesis keep */ ;
	wire[15:0] data_mem_out  /* synthesis keep */ ;
	wire[15:0] se_ad;//sign ext addr
	wire[5:0] ad;    //addr
	
	wire [15:0] data_in_bus  /* synthesis keep */  ;
	  
	
	
	//Instantiate the PC controller
	pc_controller pc_ctrl
	(
    	.rst(rst), 
		.clk(clk), 
		.N(N),
		.C(C),
		.V(V),
		.Z(Z),
		.PL(PL), 
		.JB(JB), 
		.BC(BC), 
		.PC(PC), 
		.ld_pc(se_ad), 
		.jp_addr(A)
	);
	
	// The AD field, with sign extension.
	assign ad= {instr[8:6],instr[2:0]};
	assign se_ad = {  {10{ad[5]}}, ad       };
	
	
	// Instantiate instruction memory, 1K x 16 instruction memory
	// Using only the lower 10 bits of the PC since the memory is 1K.
   // These parameters control the size of the memory.  Do not change them.
	defparam instr_mem.DATA_WIDTH = 16;
	defparam instr_mem.ADDR_WIDTH = 10;
	instruction_rom instr_mem
	(  .addr(PC[9:0]), .clk(clk), .rst(rst), .q(instr)  );
	
	
	//Instantiate instruction decoder
	instr_decoder instruction_decoder
	(
    .instr(instr),
    .DA(DA),
	 .AA(AA),
	 .BA(BA),
	 .MB(MB),
	 .FS(FS),
	 .MD(MD),
	 .RW(RW),
	 .MW(MW),
	 .PL(PL),
	 .JB(JB),
	 .BC(BC)
  );
  
  //zero fill for immediate operands.
  assign constant = {    {13{1'b0}},  instr[2:0] };
  
  
  //declare register file
  double_port_ram register_file
  (
	 .data(  (register_file_in & (~rst) )   ),
	 .DA(DA),
	 .AA(AA),
	 .BA(BA),
	 .we(RW), 
	 .clk(clk),
	 .rst(rst),
	 .a(A), 
	 .b(B),
	 .r0(r0),
	 .r1(r1),
	 .r2(r2),
	 .r3(r3),
	 .r4(r4),
	 .r5(r5),
	 .r6(r6),
	 .r7(r7)
  );
  
  //mux B
  mux mux_b
  (
	 .din_1(constant),
	 .din_0(B),
	 .sel(MB),
	 .q(mux_b_out)
  );
  
  //declare function unit
  function_unit func_unit
  (
	.FS(FS),
	.A(A),
	.B(mux_b_out),
	.V(V),
	.C(C),
	.N(N),
	.Z(Z),
	.F(function_unit_out)
  );
  
  // Instantiate the data memory
  // Data memory is 256 x 16 
  // These parameters control the size of the memory.  Do not change them.
   defparam data_mem.DATA_WIDTH = 16;
   defparam data_mem.ADDR_WIDTH = 8;
	single_port_ram data_mem
	( .data(mux_b_out), .addr(A[7:0]), .we( MW), .clk(clk), .q(data_mem_out)  );

	// Redundant now that the accelerometer has been removed.
	assign data_in_bus = data_mem_out;
	
	//mux d
   mux mux_d
  (
	 .din_1(data_in_bus),
	 .din_0(function_unit_out),
	 .sel(MD),
	 .q(register_file_in)
  );
	
  // Make the instruction register value visible outside the CPU.
  assign IR = instr;
  
  endmodule
  // End of CPU module
  
  
// This instr_decoder module corresponds to the decoder in Figure 9-16 on Page 473
// Created by Xin Xin, Virginia Tech
// 06/2012
// 

module instr_decoder 
  (
    input [15:0] instr,
    output [2:0] DA,AA,BA,
	 output MB,
	 output [3:0] FS,
	 output MD,RW,MW,PL,JB,BC
  );
  
  wire PL_temp,MW_temp,temp;
  
  assign PL_temp = instr[15] & instr[14];
  assign MW_temp = (~ instr[15]) & instr[14];
  assign temp = (~ PL_temp) & instr[9];
  
  
  assign PL= PL_temp;
  assign MW= MW_temp;
  
  assign DA = instr[8:6];
  assign AA = instr[5:3];
  assign BA = instr[2:0];
  
  assign MB= instr[15];
  assign FS= {instr[12:10], temp};
  
  assign MD= instr[13];
  assign RW= ~ instr[14];
  
  assign JB= instr[13];
  assign BC= instr[9];
  
  endmodule
  // End of instr_decoder module
  
  